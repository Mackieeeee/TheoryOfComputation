<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    body{
        background-color: #e8e9ff;

    }

    
    .box{
        background: #afb1e3;
       width: 90%;
       margin-left: 30px;
       border-radius: 10px;
       font-size: 18px;
       font-style: monospace;

    }
    p{
        margin-left: 30px;
        font-size: 20px;
        font-style: monospace;

    }
    h1{
        text-align:justify;
        color:#03074a
    }
    h2{
        text-align:justify;
        color:#03074a;
    }
    ul{
        font-size: 20px;
        font-style: oblique;
    }
    table,th,td{
        font-size: 20px;
        font-style: oblique;
        text-align: center;
        border: 2px solid #000;
        border-collapse: collapse;
    }


</style>
<body>
    <h1><b>Regular Expressions, Regular Grammar and Regular Languages</b></h1>
    
    <p>As discussed in Chomsky Hierarchy, Regular Languages are the most restricted types of languages and are accepted by finite automata.</p><br>
    <p><b>Regular Expressions</b><br>
        Regular Expressions are used to denote regular languages. An expression is regular if:</p><br>
        <ul>
            <li>ɸ is a regular expression for regular language ɸ.</li>
            <li>ɛ is a regular expression for regular language {ɛ}.</li>
            <li>If a ∈ Σ (Σ represents the input alphabet), a is regular expression with language {a}.</li>
            <li>If a and b are regular expression, a + b is also a regular expression with language {a,b}.</li>
            <li>If a and b are regular expression, ab (concatenation of a and b) is also regular.</li>
            <li>If a is regular expression, a* (0 or more times a) is also regular.</li>
        </ul><br><br>
        <table>
            <tr bgcolor="green">
                <th></th>
                <th>Regular Expression</th>
                <th>Regular Languages</th>
            </tr>
            <tr bgcolor="pink">
                <td>set of vovels</td>
                <td>( a ∪ e ∪ i ∪ o ∪ u )</td>
                <td>{a, e, i, o, u}</td>
            </tr>
            <tr bgcolor="pink">
                <td>a followed by 0 or more b</td>
                <td>(a.b*)</td>
                <td>{a, ab, abb, abbb, abbbb,….}</td>
            </tr>
            <tr bgcolor="pink">
                <td>any no. of vowels followed by any no. of consonants</td>
                <td>v*.c* ( where v – vowels and c – consonants)</td>
                <td>{ ε , a ,aou, aiou, b, abcd…..} where ε represent empty string (in case 0 vowels and o consonants )</td>
            </tr>
        </table><br><br>
        <p><b>Regular Gramma</b>r : A grammar is regular if it has rules of form A -> a or A -> aB or A -> ɛ where ɛ is a special symbol called NULL.</p><br>
        <p><b>Regular Languages</b> : A language is regular if it can be expressed in terms of regular expression.</p><br>
        <h2>Closure Properties of Regular Languages</h2><br>
        <p><b>Union</b> : If L1 and If L2 are two regular languages, their union L1 ∪ L2 will also be regular. For example, L1 = {an | n ≥ 0} and L2 = {bn | n ≥ 0}
            L3 = L1 ∪ L2 = {an ∪ bn | n ≥ 0} is also regular.</p><br>
            <p><b>Intersection</b> : If L1 and If L2 are two regular languages, their intersection L1 ∩ L2 will also be regular. For example,
                L1= {am bn | n ≥ 0 and m ≥ 0} and L2= {am bn ∪ bn am | n ≥ 0 and m ≥ 0}
                L3 = L1 ∩ L2 = {am bn | n ≥ 0 and m ≥ 0} is also regular.</p>
                <p><b>Concatenation </b>: If L1 and If L2 are two regular languages, their concatenation L1.L2 will also be regular. For example,
                    L1 = {an | n ≥ 0} and L2 = {bn | n ≥ 0}
                    L3 = L1.L2 = {am . bn | m ≥ 0 and n ≥ 0} is also regular.</p>
                    <p><b>Kleene Closure</b> : If L1 is a regular language, its Kleene closure L1* will also be regular. For example,
                        L1 = (a ∪ b)
                        L1* = (a ∪ b)*</p>
                        <p><b>Complement</b> : If L(G) is regular language, its complement L’(G) will also be regular. Complement of a language can be found by subtracting strings which are in L(G) from all possible strings. For example,
                            L(G) = {an | n > 3}
                            L’(G) = {an | n <= 3}</p><br>
                            <p><b>Note:</b> Two regular expressions are identical if the languages generated by them are the same. For example, (a+b*)* and (a+b)* produce the same language. Every string formed by (a+b*)* is also generated by (a+b)*, and vice versa.</p><br>
                            <h2>How to solve problems on regular expression and regular languages?</h2><br>
                            <p><b>Question 1</b> : Which one of the following languages over the alphabet {0,1} is described by the regular expression?
                                (0+1)*0(0+1)*0(0+1)*<br>
                                (A) The set of all strings containing the substring 00.<br>
                                (B) The set of all strings containing at most two 0’s.<br>
                                (C) The set of all strings containing at least two 0’s.<br>
                                (D) The set of all strings that begin and end with either 0 or 1.</p><br>
                                <p><b>Solution</b> :<br> <b>Option A</b> says that it must have substring 00. But 10101 is also a part of language but it does not contain 00 as substring. So it is not correct option.<br>
                                    <b>Option B</b> says that it can have maximum two 0’s but 00000 is also a part of language. So it is not correct option.<br>
                                    <b>Option C</b> says that it must contain atleast two 0. In regular expression, two 0 are present. So this is correct option.<br>
                                    <b>Option D</b> says that it contains all strings that begin and end with either 0 or 1. But it can generate strings which start with 0 and end with 1 or vice versa as well. So it is not correct.</p><br>
                                    <p><b>Question 2</b> : Which of the following languages is generated by given grammar?<br>
                                        S -> aS | bS | ∊<br>
                                        (A) {an bm | n,m ≥ 0}<br>
                                        (B) {w ∈ {a,b}* | w has equal number of a’s and b’s}<br>
                                        (C) {an | n ≥ 0} ∪ {bn | n ≥ 0} ∪ {an bn | n ≥ 0}<br>
                                        (D) {a,b}*</p><br>
                                        <p><b>Solution</b> :<br> <b>Option (A)</b> says that it will have 0 or more a followed by 0 or more b. But S -> bS => baS => ba is also a part of language. So (A) is not correct.<br>
                                            <b>Option (B)</b> says that it will have equal no. of a’s and b’s. But But S -> bS => b is also a part of language. So (B) is not correct.<br>
                                            <b>Option (C)</b> says either it will have 0 or more a’s or 0 or more b’s or a’s followed by b’s. But as shown in option (A), ba is also part of language. So (C) is not correct.<br>
                                            <b>Option (D)</b> says it can have any number of a’s and any numbers of b’s in any order. So (D) is correct.</p><br>
                                            <p><b>Question 3</b> : The regular expression 0*(10*)* denotes the same set as<br>
                                                (A) (1*0)*1*<br>
                                                (B) 0 + (0 + 10)*<br>
                                                (C) (0 + 1)* 10(0 + 1)*<br>
                                                (D) none of these</p><br>
                                                <p><b>Solution</b> : Two regular expressions are equivalent if languages generated by them are same.<br> 
                                                    <b>Option (A)</b> can generate all strings generated by 0*(10*)*. So they are equivalent.<br> 
                                                    <b>Option (B)</b> string null can not generated by given languages but 0*(10*)* can. So they are not equivalent.<br> 
                                                    <b>Option (C)</b> will have 10 as substring but 0*(10*)* may or may not. So they are not equivalent.</p><br> 
                                                    <p><b>Question 4</b> : The regular expression for the language having input alphabets a and b, in which two a’s do not come together:<br>
                                                        (A) (b + ab)* + (b +ab)*a<br>
                                                        (B) a(b + ba)* + (b + ba)*<br>
                                                        (C) both options (A) and (B)<br>
                                                        (D) none of the above</p><br>
                                                        <p><b>Solution</b>:
                                                            Option (C) stating both both options (A) and (B) is the correct regular expression for the stated question.<br>
                                                            The language in the question can be expressed as L={&epsilon;,a,b,bb,ab,aba,ba,bab,baba,abab,…}.<br><br>
                                                            
                                                            In option (A) ‘ab’ is considered the building block for finding out the required regular expression.(b + ab)* covers all cases of strings generated ending with ‘b’.(b + ab)*a covers all cases of strings generated ending with a.<br><br>
                                                            
                                                            Applying similar logic for option (B) we can see that the regular expression is derived considering ‘ba’ as the building block and it covers all cases of strings starting with a and starting with b.<br><br>
                                                            
                                                            


</body>
</html>